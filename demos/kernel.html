<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parallel File Append Operations</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');
        
        :root {
            --process1-color: #4361ee;
            --process1-light: rgba(67, 97, 238, 0.15);
            --process2-color: #f72585;
            --process2-light: rgba(247, 37, 133, 0.15);
            --kernel-color: #ff9e00;
            --kernel-light: rgba(255, 158, 0, 0.15);
            --hardware-color: #38b000;
            --hardware-light: rgba(56, 176, 0, 0.15);
            --highlight-color: #7209b7;
            --dark-text: #2b2d42;
            --mid-text: #575a7b;
            --light-text: #8d99ae;
            --background: #f8f9fa;
            --layer-bg: #ffffff;
            --borders: #e9ecef;
            --tooltip-bg: rgba(43, 45, 66, 0.95);
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background);
            color: var(--dark-text);
            line-height: 1.6;
            padding: 0;
            margin: 0;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        header {
            margin-bottom: 2rem;
            text-align: center;
        }
        
        h1 {
            font-weight: 700;
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: var(--dark-text);
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: var(--mid-text);
            max-width: 800px;
            margin: 0 auto 1.5rem;
        }
        
        .visualization-container {
            position: relative;
            background: var(--layer-bg);
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 600px;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            padding: 1rem;
            gap: 1rem;
            background-color: var(--layer-bg);
            border-top: 1px solid var(--borders);
        }
        
        button {
            background: var(--layer-bg);
            border: 1px solid var(--borders);
            color: var(--dark-text);
            padding: 0.75rem 1.25rem;
            border-radius: 8px;
            font-weight: 500;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        button:hover {
            background-color: var(--borders);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button svg {
            width: 18px;
            height: 18px;
        }
        
        button.primary {
            background: var(--process1-color);
            border-color: var(--process1-color);
            color: white;
        }
        
        button.primary:hover {
            background: #3854d1;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin: 1rem auto;
            max-width: 800px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }
        
        .timeline {
            background: var(--borders);
            height: 4px;
            margin: 1rem 0;
            border-radius: 2px;
            position: relative;
        }
        
        .timeline-progress {
            background: var(--process1-color);
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        .timeline-markers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            pointer-events: none;
        }
        
        .timeline-marker {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--layer-bg);
            border: 2px solid var(--process1-color);
            border-radius: 50%;
            top: -2px;
            transform: translateX(-50%);
            transition: transform 0.2s ease;
        }
        
        .timeline-marker.active {
            transform: translateX(-50%) scale(1.5);
        }
        
        .step-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .step-count {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--mid-text);
        }
        
        .step-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 0;
        }
        
        .step-description {
            background: var(--layer-bg);
            border-radius: 8px;
            padding: 1.25rem;
            margin-top: 1rem;
            border: 1px solid var(--borders);
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }
        
        .hotspot {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid var(--highlight-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            pointer-events: none;
            z-index: 10;
        }
        
        .hotspot.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .hotspot:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
        }
        
        .hotspot::after {
            content: "i";
            font-family: serif;
            font-style: italic;
            font-weight: bold;
            font-size: 14px;
            color: var(--highlight-color);
        }
        
        .tooltip {
            position: absolute;
            background: var(--tooltip-bg);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.85rem;
            max-width: 280px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }
        
        .tooltip.active {
            opacity: 1;
        }
        
        .tooltip h4 {
            margin: 0 0 0.5rem;
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .tooltip p {
            margin: 0;
            font-weight: 400;
            line-height: 1.4;
        }
        
        .code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85em;
            padding: 0.1em 0.3em;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
        }
        
        .highlight-pulse {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .fade-in {
            animation: fadeIn 0.5s forwards;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--process1-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .particle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        .callout {
            position: absolute;
            background: var(--layer-bg);
            border: 1px solid var(--borders);
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 0.85rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            max-width: 250px;
        }
        
        .callout.active {
            opacity: 1;
        }
        
        .detail-view {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 250px;
            background: var(--layer-bg);
            border: 1px solid var(--borders);
            border-radius: 8px;
            padding: 1rem;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 20;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .detail-view.active {
            opacity: 1;
        }
        
        .detail-view h4 {
            margin: 0 0 0.5rem;
            font-size: 0.95rem;
            font-weight: 600;
        }
        
        .detail-view .code-block {
            background: #f5f5f5;
            padding: 0.5rem;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
            overflow: auto;
            white-space: pre;
        }
        
        .jump-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
        }
        
        .jump-btn {
            background: none;
            border: none;
            color: var(--process1-color);
            cursor: pointer;
            font-size: 0.85rem;
            padding: 0;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .jump-btn:hover {
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .canvas-container {
                height: 450px;
            }
            
            .controls {
                flex-wrap: wrap;
            }
            
            button {
                padding: 0.5rem 1rem;
                font-size: 0.9rem;
            }
            
            .detail-view {
                bottom: 10px;
                right: 10px;
                width: 220px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Parallel File Append Operation</h1>
            <p class="subtitle">A deep dive into what happens at the OS, kernel, and hardware level when two processes simultaneously append to a file descriptor.</p>
        </header>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--process1-color);"></div>
                <span>Process 1</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--process2-color);"></div>
                <span>Process 2</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--kernel-color);"></div>
                <span>Kernel Operations</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--hardware-color);"></div>
                <span>Hardware I/O</span>
            </div>
        </div>
        
        <div class="visualization-container">
            <div class="step-info">
                <span class="step-count" id="stepCounter">Step 1/15</span>
                <h2 class="step-title" id="stepTitle">Initial State</h2>
            </div>
            
            <div class="timeline">
                <div class="timeline-progress" id="timelineProgress"></div>
                <div class="timeline-markers" id="timelineMarkers"></div>
            </div>
            
            <div class="canvas-container">
                <canvas id="visualizationCanvas"></canvas>
                <div class="particle-container" id="particleContainer"></div>
                <div class="tooltip" id="tooltip"></div>
                <div id="hotspots"></div>
                <div id="callouts"></div>
                <div class="detail-view" id="detailView">
                    <h4>System Call Details</h4>
                    <div class="code-block">write(fd, buffer, size);</div>
                    <p>Transfers data from user space to kernel space, initiating the I/O operation.</p>
                    <div class="jump-controls">
                        <button class="jump-btn" id="prevJumpBtn">
                            <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none"><polyline points="15 18 9 12 15 6"></polyline></svg>
                            Previous
                        </button>
                        <button class="jump-btn" id="nextJumpBtn">
                            Next
                            <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none"><polyline points="9 18 15 12 9 6"></polyline></svg>
                        </button>
                    </div>
                </div>
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                </div>
            </div>
            
            <div class="controls">
                <button id="prevBtn" disabled>
                    <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none"><polyline points="15 18 9 12 15 6"></polyline></svg>
                    Previous
                </button>
                <button id="playPauseBtn" class="primary">
                    <svg id="playIcon" viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    <svg id="pauseIcon" viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none" style="display: none;"><line x1="6" y1="4" x2="6" y2="20"></line><line x1="18" y1="4" x2="18" y2="20"></line></svg>
                    Play
                </button>
                <button id="nextBtn">
                    Next
                    <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </button>
                <button id="resetBtn">
                    <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
                    Reset
                </button>
            </div>
        </div>
        
        <div class="step-description" id="stepDescription">
            Two separate processes are running in parallel, each preparing to append data to the same file. Each process has its own memory space and runs independently.
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Canvas and context setup
            const canvas = document.getElementById('visualizationCanvas');
            const ctx = canvas.getContext('2d');
            
            // DOM elements
            const particleContainer = document.getElementById('particleContainer');
            const tooltip = document.getElementById('tooltip');
            const hotspotsContainer = document.getElementById('hotspots');
            const calloutsContainer = document.getElementById('callouts');
            const detailView = document.getElementById('detailView');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const stepCounter = document.getElementById('stepCounter');
            const stepTitle = document.getElementById('stepTitle');
            const stepDescription = document.getElementById('stepDescription');
            const timelineProgress = document.getElementById('timelineProgress');
            const timelineMarkers = document.getElementById('timelineMarkers');
            
            // Control buttons
            const playPauseBtn = document.getElementById('playPauseBtn');
            const playIcon = document.getElementById('playIcon');
            const pauseIcon = document.getElementById('pauseIcon');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const resetBtn = document.getElementById('resetBtn');
            const prevJumpBtn = document.getElementById('prevJumpBtn');
            const nextJumpBtn = document.getElementById('nextJumpBtn');
            
            // Constants
            const COLORS = {
                process1: getComputedStyle(document.documentElement).getPropertyValue('--process1-color').trim(),
                process1Light: getComputedStyle(document.documentElement).getPropertyValue('--process1-light').trim(),
                process2: getComputedStyle(document.documentElement).getPropertyValue('--process2-color').trim(),
                process2Light: getComputedStyle(document.documentElement).getPropertyValue('--process2-light').trim(),
                kernel: getComputedStyle(document.documentElement).getPropertyValue('--kernel-color').trim(),
                kernelLight: getComputedStyle(document.documentElement).getPropertyValue('--kernel-light').trim(),
                hardware: getComputedStyle(document.documentElement).getPropertyValue('--hardware-color').trim(),
                hardwareLight: getComputedStyle(document.documentElement).getPropertyValue('--hardware-light').trim(),
                highlight: getComputedStyle(document.documentElement).getPropertyValue('--highlight-color').trim(),
                darkText: getComputedStyle(document.documentElement).getPropertyValue('--dark-text').trim(),
                midText: getComputedStyle(document.documentElement).getPropertyValue('--mid-text').trim(),
                lightText: getComputedStyle(document.documentElement).getPropertyValue('--light-text').trim(),
                border: getComputedStyle(document.documentElement).getPropertyValue('--borders').trim(),
                background: getComputedStyle(document.documentElement).getPropertyValue('--background').trim(),
                layerBg: getComputedStyle(document.documentElement).getPropertyValue('--layer-bg').trim()
            };
            
            const ANIMATION_DURATION = 800; // ms
            const AUTO_ADVANCE_DELAY = 3000; // ms
            
            // State
            let currentStep = 0;
            let isPlaying = false;
            let animationFrameId = null;
            let autoAdvanceTimer = null;
            let transitionProgress = 1; // 0 to 1
            let isTransitioning = false;
            let hotspots = [];
            let callouts = [];
            let particles = [];
            let canvasWidth, canvasHeight;
            let dpr = window.devicePixelRatio || 1;
            
            // Layer definitions
            const layers = [
                { id: 'process1', name: 'Process 1', type: 'process', y: 0.12, color: COLORS.process1, lightColor: COLORS.process1Light },
                { id: 'process2', name: 'Process 2', type: 'process', y: 0.22, color: COLORS.process2, lightColor: COLORS.process2Light },
                { id: 'syscall', name: 'Kernel - System Call Interface', type: 'kernel', y: 0.36, color: COLORS.kernel, lightColor: COLORS.kernelLight },
                { id: 'vfs', name: 'Kernel - VFS Layer', type: 'kernel', y: 0.48, color: COLORS.kernel, lightColor: COLORS.kernelLight },
                { id: 'fs', name: 'Kernel - File System Driver', type: 'kernel', y: 0.60, color: COLORS.kernel, lightColor: COLORS.kernelLight },
                { id: 'cache', name: 'Hardware - Buffer Cache', type: 'hardware', y: 0.75, color: COLORS.hardware, lightColor: COLORS.hardwareLight },
                { id: 'disk', name: 'Hardware - Storage Device', type: 'hardware', y: 0.87, color: COLORS.hardware, lightColor: COLORS.hardwareLight }
            ];
            
            // Animation steps with detailed state information
            const steps = [
                {
                    id: 'initial',
                    title: 'Initial State',
                    description: 'Two separate processes are running in parallel, each preparing to append data to the same file. Each process has its own memory space and runs independently.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: true, data: 'Hello', status: 'Ready to write' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: true, data: 'World', status: 'Ready to write' }
                        ],
                        arrows: [],
                        activities: [],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing File Content' },
                        locks: [],
                        dataPackets: []
                    },
                    hotspots: [
                        { 
                            x: 0.2, 
                            y: layers[0].y, 
                            title: 'User Process', 
                            content: 'A process is an instance of a running program. It has its own memory space and resources. This process wants to append "Hello" to a file.' 
                        },
                        { 
                            x: 0.8, 
                            y: layers[6].y, 
                            title: 'File on Disk', 
                            content: 'Files are stored on persistent storage devices. When processes write data, it must eventually reach the physical storage.' 
                        }
                    ],
                    callouts: [
                        { x: 0.5, y: 0.3, content: 'Each process runs in its own memory space in <span class="code">USER MODE</span>' }
                    ],
                    detailView: {
                        title: 'Process & File State',
                        code: 'int fd = open("file.txt", O_APPEND | O_WRONLY);\nchar *data = "Hello"; // Process 1\nchar *data = "World"; // Process 2',
                        description: 'Both processes open the same file with the O_APPEND flag, which ensures data will be written at the end of the file.'
                    }
                },
                {
                    id: 'syscall-initiation',
                    title: 'System Call Initiation',
                    description: 'Both processes simultaneously make a write() system call to append their data. The system call is the interface between user space (where processes run) and kernel space.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: true, data: 'Hello', status: 'write(fd, "Hello", 5)' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: true, data: 'World', status: 'write(fd, "World", 5)' }
                        ],
                        arrows: [
                            { from: { x: 0.2, y: layers[0].y }, to: { x: 0.2, y: layers[2].y }, color: COLORS.process1 },
                            { from: { x: 0.2, y: layers[1].y }, to: { x: 0.2, y: layers[2].y }, color: COLORS.process2 }
                        ],
                        activities: [
                            { x: 0.2, y: layers[2].y, color: COLORS.kernel, content: 'System Call Handler' }
                        ],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing File Content' },
                        locks: [],
                        dataPackets: []
                    },
                    hotspots: [
                        { 
                            x: 0.2, 
                            y: layers[2].y, 
                            title: 'System Call Interface', 
                            content: 'The system call interface is the boundary between user space and kernel space. When a process makes a system call, execution transitions from user mode to kernel mode with elevated privileges.' 
                        }
                    ],
                    callouts: [
                        { x: 0.35, y: 0.36, content: 'System calls transfer control from <span class="code">USER MODE</span> to <span class="code">KERNEL MODE</span>' }
                    ],
                    detailView: {
                        title: 'Write System Call',
                        code: 'ssize_t write(int fd, const void *buf, size_t count);\n\n// Process 1: write(fd, "Hello", 5);\n// Process 2: write(fd, "World", 5);',
                        description: 'The write() system call tells the kernel to write data from a buffer in the process memory to a file represented by a file descriptor.'
                    }
                },
                {
                    id: 'context-switch',
                    title: 'Kernel Processing - Context Switch',
                    description: 'The CPU switches from user mode to kernel mode. The kernel validates the file descriptor and prepares to handle the write operations. Each process is now waiting for the kernel to complete its request.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: false, data: 'Hello', status: 'Waiting...' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: false, data: 'World', status: 'Waiting...' }
                        ],
                        arrows: [
                            { from: { x: 0.2, y: layers[2].y }, to: { x: 0.25, y: layers[3].y }, color: COLORS.kernel }
                        ],
                        activities: [
                            { x: 0.2, y: layers[2].y, color: COLORS.kernel, content: 'Context Switch to Kernel Mode' },
                            { x: 0.25, y: layers[3].y, color: COLORS.kernel, content: 'VFS: Validate File Descriptor' }
                        ],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing File Content' },
                        locks: [],
                        dataPackets: []
                    },
                    hotspots: [
                        { 
                            x: 0.2, 
                            y: layers[2].y, 
                            title: 'Context Switch', 
                            content: 'A context switch occurs when the CPU switches from executing in user mode to kernel mode. This includes saving the current CPU state and loading the kernel state.' 
                        },
                        { 
                            x: 0.25, 
                            y: layers[3].y, 
                            title: 'Virtual File System (VFS)', 
                            content: 'The VFS is an abstraction layer that provides a common interface for different file systems. It handles file operations regardless of the underlying file system type.' 
                        }
                    ],
                    callouts: [
                        { x: 0.4, y: 0.48, content: 'Kernel checks if the file descriptor is valid and the process has permissions to write' }
                    ],
                    detailView: {
                        title: 'Context Switch Details',
                        code: '/* In kernel, handling the system call */\nsys_write(unsigned int fd, const char __user *buf,\n         size_t count) {\n  struct file *file = fget(fd);\n  if (!file)\n    return -EBADF; /* Bad file descriptor */\n  ...',
                        description: 'The kernel first validates that the file descriptor exists and represents an open file that the process has permission to write to.'
                    }
                },
                {
                    id: 'vfs-processing',
                    title: 'VFS Layer Processing',
                    description: 'The Virtual File System (VFS) layer processes the write requests and detects that two processes are trying to append to the same file simultaneously. The VFS must ensure data consistency.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: false, data: 'Hello', status: 'Waiting...' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: false, data: 'World', status: 'Waiting...' }
                        ],
                        arrows: [],
                        activities: [
                            { x: 0.2, y: layers[2].y, color: COLORS.kernel, content: 'Syscall Processing' },
                            { x: 0.35, y: layers[3].y, color: COLORS.kernel, content: 'VFS: Handling Concurrent Requests', highlight: true }
                        ],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing File Content' },
                        locks: [],
                        dataPackets: []
                    },
                    hotspots: [
                        { 
                            x: 0.35, 
                            y: layers[3].y, 
                            title: 'Concurrent Request Handling', 
                            content: 'The VFS detects that multiple processes are trying to write to the same file. Without proper synchronization, this could lead to data corruption or race conditions.' 
                        }
                    ],
                    callouts: [
                        { x: 0.55, y: 0.48, content: 'Race condition detected! Two processes attempting to append to the same file' }
                    ],
                    detailView: {
                        title: 'Race Condition Details',
                        code: '/* Without proper synchronization */\n// P1: Read EOF = 1000\n// P2: Read EOF = 1000\n// P1: Write at offset 1000\n// P2: Write at offset 1000 (overwrites P1!)',
                        description: 'A race condition occurs when multiple processes access and manipulate the same data concurrently. Without synchronization, one process might overwrite another\'s data.'
                    }
                },
                {
                    id: 'kernel-locking',
                    title: 'Kernel Locking Mechanism',
                    description: 'To prevent race conditions, the kernel uses locking mechanisms. For file appends, the kernel acquires an inode lock to ensure that only one operation can modify the file size and offset at a time.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: false, data: 'Hello', status: 'Waiting...' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: false, data: 'World', status: 'Waiting...' }
                        ],
                        arrows: [],
                        activities: [
                            { x: 0.3, y: layers[3].y, color: COLORS.kernel, content: 'VFS: Acquire File Locks' }
                        ],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing File Content' },
                        locks: [
                            { x: 0.4, y: layers[3].y, locked: true, owner: 'p1', message: 'Process 1 acquires inode lock first' }
                        ],
                        dataPackets: []
                    },
                    hotspots: [
                        { 
                            x: 0.4, 
                            y: layers[3].y, 
                            title: 'Inode Locking', 
                            content: 'The inode is a data structure that stores metadata about a file. Locking the inode prevents race conditions by ensuring that only one process can modify the file\'s metadata (like size) at a time.' 
                        }
                    ],
                    callouts: [
                        { x: 0.6, y: 0.36, content: 'Kernel uses locks to synchronize access to shared resources' }
                    ],
                    detailView: {
                        title: 'File Locking in the Kernel',
                        code: '/* In VFS write implementation */\nstatic ssize_t new_sync_write(struct file *filp, const char __user *buf,\n                        size_t len, loff_t *ppos) {\n  struct inode *inode = filp->f_path.dentry->d_inode;\n  mutex_lock(&inode->i_mutex); // Acquire inode lock\n  /* Critical section */\n  ...',
                        description: 'The kernel uses mutexes and semaphores to ensure exclusive access to critical resources. For file operations, it typically locks the inode structure.'
                    }
                },
                {
                    id: 'process1-fs-driver',
                    title: 'Process 1 Filesystem Driver Interaction',
                    description: 'With the lock acquired, Process 1\'s write request proceeds. The file system driver calculates where to write the data, based on the current end of file. For appends, it uses the current file size as the offset.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: true, data: 'Hello', status: 'Active (has lock)' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: false, data: 'World', status: 'Waiting for lock...' }
                        ],
                        arrows: [
                            { from: { x: 0.3, y: layers[3].y }, to: { x: 0.35, y: layers[4].y }, color: COLORS.process1 }
                        ],
                        activities: [
                            { x: 0.35, y: layers[4].y, color: COLORS.kernel, content: 'FS Driver: Calculate Append Position' }
                        ],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing File Content' },
                        locks: [
                            { x: 0.4, y: layers[3].y, locked: true, owner: 'p1', message: 'Lock held by Process 1' }
                        ],
                        dataPackets: []
                    },
                    hotspots: [
                        { 
                            x: 0.35, 
                            y: layers[4].y, 
                            title: 'File System Driver', 
                            content: 'The file system driver is responsible for translating VFS operations into actions specific to the actual file system (ext4, NTFS, etc.). For an append operation, it needs to determine the current file size.' 
                        }
                    ],
                    callouts: [
                        { x: 0.55, y: 0.6, content: 'For O_APPEND, the kernel automatically sets the file position to the end of file before each write' }
                    ],
                    detailView: {
                        title: 'Append Mode Behavior',
                        code: '/* In file_write_iter function */\nif (filp->f_flags & O_APPEND) {\n  /* Force the current file position to EOF */\n  inode_lock(inode);\n  pos = i_size_read(inode);\n  /* Now Process 1 knows it will write at the current EOF */\n}',
                        description: 'When a file is opened with O_APPEND flag, the kernel ensures that every write happens at the end of file by setting the position to the current file size before writing.'
                    }
                },
                {
                    id: 'process1-buffer-cache',
                    title: 'Buffer Cache Interaction for Process 1',
                    description: 'The file system doesn\'t write directly to disk. Instead, it works with the buffer cache - an area of memory that temporarily stores data to be written. The data "Hello" is copied to the buffer cache.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: true, data: 'Hello', status: 'Active (has lock)' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: false, data: 'World', status: 'Waiting for lock...' }
                        ],
                        arrows: [
                            { from: { x: 0.35, y: layers[4].y }, to: { x: 0.45, y: layers[5].y }, color: COLORS.process1 }
                        ],
                        activities: [
                            { x: 0.45, y: layers[5].y, color: COLORS.hardware, content: 'Buffer Cache: Adding "Hello"' }
                        ],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing File Content' },
                        locks: [
                            { x: 0.4, y: layers[3].y, locked: true, owner: 'p1', message: 'Lock held by Process 1' }
                        ],
                        dataPackets: [
                            { x: 0.5, y: layers[5].y - 0.03, color: COLORS.process1, data: 'Hello', position: 'Position: EOF' }
                        ]
                    },
                    hotspots: [
                        { 
                            x: 0.45, 
                            y: layers[5].y, 
                            title: 'Buffer Cache', 
                            content: 'The buffer cache is an in-memory cache of disk blocks. It improves performance by reducing the need for physical disk I/O operations and allowing for write coalescing.' 
                        }
                    ],
                    callouts: [
                        { x: 0.65, y: 0.7, content: 'Data is first written to memory buffers, not directly to disk' }
                    ],
                    detailView: {
                        title: 'Memory-to-Memory Copy',
                        code: '/* Copy data from user space to kernel buffers */\nif (copy_from_user(kbuf, buf, count)) {\n  return -EFAULT; /* Bad address */\n}\n\n/* Add to file system buffer cache */\nbh = sb_getblk(sb, block);\nmemcpy(bh->b_data + offset, kbuf, count);\nmark_buffer_dirty(bh);',
                        description: 'The kernel first copies data from the user process memory to kernel memory, then copies it to the buffer cache. This allows the process to continue execution while the actual disk I/O happens later.'
                    }
                },
                {
                    id: 'process1-completion',
                    title: 'Process 1 Completion and Lock Release',
                    description: 'Once Process 1\'s data is in the buffer cache, the kernel can consider the write operation complete from the process\'s perspective. The inode lock is released, and the process can continue execution.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: true, data: 'Hello', status: 'Write completed' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: false, data: 'World', status: 'Waiting for lock...' }
                        ],
                        arrows: [
                            { from: { x: 0.3, y: layers[2].y }, to: { x: 0.2, y: layers[0].y }, color: COLORS.process1 }
                        ],
                        activities: [],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing File Content' },
                        locks: [
                            { x: 0.4, y: layers[3].y, locked: false, owner: null, message: 'Process 1 releases lock' }
                        ],
                        dataPackets: [
                            { x: 0.5, y: layers[5].y - 0.03, color: COLORS.process1, data: 'Hello', position: 'Position: EOF' }
                        ]
                    },
                    hotspots: [
                        { 
                            x: 0.2, 
                            y: layers[0].y, 
                            title: 'Write Completion', 
                            content: 'From the process\'s perspective, the write is complete once the data is safely in the kernel\'s hands. The process doesn\'t wait for the data to be physically written to disk before continuing.' 
                        }
                    ],
                    callouts: [
                        { x: 0.25, y: 0.2, content: 'Process 1 can continue execution before data is physically written to disk' }
                    ],
                    detailView: {
                        title: 'System Call Return',
                        code: '/* At the end of the write system call */\nmutex_unlock(&inode->i_mutex); // Release inode lock\n\nreturn written; // Return number of bytes written\n\n/* Control returns to user process */\nret = write(fd, "Hello", 5);\nif (ret == 5) {\n  /* Write successful */\n}',
                        description: 'The write system call returns the number of bytes written (or an error code). The process continues execution from that point, regardless of whether the data has reached the physical disk yet.'
                    }
                },
                {
                    id: 'process2-lock-acquisition',
                    title: 'Process 2 Acquires Lock',
                    description: 'Now that the lock is available, Process 2 can acquire it and proceed with its write operation. The kernel repeats similar steps for Process 2\'s write request.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: true, data: 'Hello', status: 'Continuing execution' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: true, data: 'World', status: 'Active (acquired lock)' }
                        ],
                        arrows: [
                            { from: { x: 0.3, y: layers[3].y }, to: { x: 0.35, y: layers[4].y }, color: COLORS.process2 }
                        ],
                        activities: [
                            { x: 0.35, y: layers[4].y, color: COLORS.kernel, content: 'FS Driver: Calculate Append Position' }
                        ],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing File Content' },
                        locks: [
                            { x: 0.4, y: layers[3].y, locked: true, owner: 'p2', message: 'Process 2 acquires inode lock' }
                        ],
                        dataPackets: [
                            { x: 0.5, y: layers[5].y - 0.03, color: COLORS.process1, data: 'Hello', position: 'Position: EOF' }
                        ]
                    },
                    hotspots: [
                        { 
                            x: 0.4, 
                            y: layers[3].y, 
                            title: 'Lock Handoff', 
                            content: 'After Process 1 releases the lock, Process 2 can acquire it. The lock ensures that only one process modifies the file at a time, preventing race conditions.' 
                        }
                    ],
                    callouts: [
                        { x: 0.6, y: 0.36, content: 'Sequential lock acquisition ensures deterministic ordering of operations' }
                    ],
                    detailView: {
                        title: 'Updated File State',
                        code: '/* Process 2 now checks the EOF position */\nif (filp->f_flags & O_APPEND) {\n  inode_lock(inode);\n  pos = i_size_read(inode); // Now EOF = original + 5\n  /* Process 2 will write at updated EOF position */\n}',
                        description: 'Important: When Process 2 checks the file size, it sees the updated size that includes Process 1\'s data (even though that data might still be only in the buffer cache). This ensures the data is appended in the correct order.'
                    }
                },
                {
                    id: 'process2-buffer-cache',
                    title: 'Process 2 Buffer Cache Interaction',
                    description: 'Process 2\'s data ("World") is now copied to the buffer cache. Importantly, since Process 1\'s data has already updated the file size in memory, Process 2\'s data will be placed after Process 1\'s data.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: true, data: 'Hello', status: 'Continuing execution' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: true, data: 'World', status: 'Active (has lock)' }
                        ],
                        arrows: [
                            { from: { x: 0.35, y: layers[4].y }, to: { x: 0.45, y: layers[5].y }, color: COLORS.process2 }
                        ],
                        activities: [
                            { x: 0.45, y: layers[5].y, color: COLORS.hardware, content: 'Buffer Cache: Adding "World"' }
                        ],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing File Content' },
                        locks: [
                            { x: 0.4, y: layers[3].y, locked: true, owner: 'p2', message: 'Lock held by Process 2' }
                        ],
                        dataPackets: [
                            { x: 0.5, y: layers[5].y - 0.03, color: COLORS.process1, data: 'Hello', position: 'Position: EOF' },
                            { x: 0.58, y: layers[5].y + 0.03, color: COLORS.process2, data: 'World', position: 'Position: EOF+5' }
                        ]
                    },
                    hotspots: [
                        { 
                            x: 0.58, 
                            y: layers[5].y + 0.03, 
                            title: 'Data Ordering', 
                            content: 'Process 2\'s data is positioned after Process 1\'s data in the buffer cache. This ordering is guaranteed by the lock mechanism, ensuring data is appended in the order that processes acquired the lock.' 
                        }
                    ],
                    callouts: [
                        { x: 0.7, y: 0.75, content: '"World" will be placed at position EOF+5, immediately after "Hello"' }
                    ],
                    detailView: {
                        title: 'In-Memory File Size Update',
                        code: '/* After copying Process 2\'s data to buffer */\n\n/* Update the in-memory inode size */\ni_size_write(inode, pos + bytes_written);\n\n/* The file size is now EOF + 5 + 5 */\n/* Both writes are in the buffer cache */\n/* But possibly not yet on disk */\n',
                        description: 'Even though neither write has necessarily reached the physical disk yet, the kernel keeps track of the logical file size in memory. This ensures correct ordering of concurrent operations.'
                    }
                },
                {
                    id: 'process2-completion',
                    title: 'Process 2 Completion and Lock Release',
                    description: 'Process 2\'s write operation is also considered complete from the process\'s perspective. The lock is released, and Process 2 can continue its execution.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: true, data: 'Hello', status: 'Continuing execution' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: true, data: 'World', status: 'Write completed' }
                        ],
                        arrows: [
                            { from: { x: 0.3, y: layers[2].y }, to: { x: 0.2, y: layers[1].y }, color: COLORS.process2 }
                        ],
                        activities: [],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing File Content' },
                        locks: [
                            { x: 0.4, y: layers[3].y, locked: false, owner: null, message: 'Process 2 releases lock' }
                        ],
                        dataPackets: [
                            { x: 0.5, y: layers[5].y - 0.03, color: COLORS.process1, data: 'Hello', position: 'Position: EOF' },
                            { x: 0.58, y: layers[5].y + 0.03, color: COLORS.process2, data: 'World', position: 'Position: EOF+5' }
                        ]
                    },
                    hotspots: [
                        { 
                            x: 0.2, 
                            y: layers[1].y, 
                            title: 'Process 2 Completion', 
                            content: 'Like Process 1, Process 2 can continue execution once its data is handed off to the kernel. Both processes have completed their write operations, but the data may still be in the buffer cache rather than on disk.' 
                        }
                    ],
                    callouts: [
                        { x: 0.25, y: 0.22, content: 'Both processes have completed their write operations from their perspective' }
                    ],
                    detailView: {
                        title: 'Write Completion',
                        code: '/* Both system calls have completed */\n\n/* Process 1 */\nint ret1 = write(fd, "Hello", 5); // Returns 5\n\n/* Process 2 */\nint ret2 = write(fd, "World", 5); // Returns 5\n\n/* Both processes continue execution */\n',
                        description: 'Both write system calls have returned successfully, indicating to each process that their data has been accepted by the kernel for writing. The actual disk I/O happens asynchronously.'
                    }
                },
                {
                    id: 'async-disk-io',
                    title: 'Asynchronous Disk I/O',
                    description: 'The actual writing to disk typically happens asynchronously. The kernel\'s page/buffer cache periodically flushes dirty pages to disk, or when explicitly requested (e.g., through fsync()). This is known as write-back caching.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: true, data: 'Hello', status: 'Continuing execution' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: true, data: 'World', status: 'Continuing execution' }
                        ],
                        arrows: [
                            { from: { x: 0.58, y: layers[5].y }, to: { x: 0.65, y: layers[6].y }, color: COLORS.hardware }
                        ],
                        activities: [
                            { x: 0.58, y: layers[5].y, color: COLORS.hardware, content: 'Buffer Cache: Flushing to Disk' }
                        ],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing File Content' },
                        locks: [],
                        dataPackets: [
                            { x: 0.5, y: layers[5].y - 0.03, color: COLORS.process1, data: 'Hello', position: ' To Disk' },
                            { x: 0.58, y: layers[5].y + 0.03, color: COLORS.process2, data: 'World', position: ' To Disk' }
                        ]
                    },
                    hotspots: [
                        { 
                            x: 0.58, 
                            y: layers[5].y, 
                            title: 'Write-Back Caching', 
                            content: 'Write-back caching improves performance by deferring disk I/O. Multiple writes can be coalesced into a single physical I/O operation, reducing disk activity. This happens after both processes have continued execution.' 
                        }
                    ],
                    callouts: [
                        { x: 0.7, y: 0.65, content: 'Kernel\'s "pdflush" or "kworker" threads handle the actual disk writes asynchronously' }
                    ],
                    detailView: {
                        title: 'Asynchronous I/O',
                        code: '/* Kernel background threads periodically flush dirty buffers */\n\n/* Or explicitly via */\nfsync(fd); // Force data to be written to physical storage\n\n/* Or when buffers need to be reclaimed */\n/* Or when a timeout is reached */\n\n/* This is transparent to the user processes */\n',
                        description: 'The kernel uses several mechanisms to determine when to flush dirty buffers to disk: periodic timers, memory pressure, explicit sync requests, or system shutdown. This is entirely transparent to user processes.'
                    }
                },
                {
                    id: 'physical-disk-io',
                    title: 'Physical Disk I/O',
                    description: 'The disk controller receives commands to write the data. For traditional hard drives, this involves moving the physical head to the right position on the disk. For SSDs, it involves more complex flash memory operations.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: true, data: 'Hello', status: 'Continuing execution' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: true, data: 'World', status: 'Continuing execution' }
                        ],
                        arrows: [],
                        activities: [
                            { x: 0.7, y: layers[6].y, color: COLORS.hardware, content: 'Disk Controller: Writing Data', highlight: true }
                        ],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing File Content' },
                        locks: [],
                        dataPackets: [
                            { x: 0.58, y: layers[5].y, color: '#aaaaaa', data: 'Cache Flushing', position: '' }
                        ]
                    },
                    hotspots: [
                        { 
                            x: 0.7, 
                            y: layers[6].y, 
                            title: 'Disk Controller Operations', 
                            content: 'The disk controller manages the physical writing of data to storage media. It handles the low-level details such as sector addressing, error correction, and physical movement of components (for HDDs) or cell programming (for SSDs).' 
                        }
                    ],
                    callouts: [
                        { x: 0.8, y: 0.87, content: 'Physical I/O involves hardware-specific operations like head movement or flash programming' }
                    ],
                    detailView: {
                        title: 'Storage Device Operations',
                        code: '/* For a traditional HDD */\n1. Move disk arm to correct track\n2. Wait for sector to rotate under head\n3. Write data to magnetic medium\n\n/* For an SSD */\n1. Translate logical block to flash page\n2. Program flash cells\n3. Update Flash Translation Layer (FTL)\n',
                        description: 'The actual physical operation differs significantly between storage types. HDDs involve mechanical movements, while SSDs involve electronic operations on flash memory cells. These details are abstracted from both the kernel and user processes.'
                    }
                },
                {
                    id: 'disk-io-completion',
                    title: 'Completion of Disk I/O',
                    description: 'Once the disk controller completes the write operations, both pieces of data have been physically written to the storage device. The file now contains the appended data from both processes in the correct order.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: true, data: 'Hello', status: 'Continuing execution' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: true, data: 'World', status: 'Continuing execution' }
                        ],
                        arrows: [],
                        activities: [
                            { x: 0.58, y: layers[5].y, color: '#aaaaaa', content: 'Buffer Cache: Clean' }
                        ],
                        file: { x: 0.8, y: layers[6].y, content: 'Existing Content + Hello + World', highlight: true },
                        locks: [],
                        dataPackets: []
                    },
                    hotspots: [
                        { 
                            x: 0.8, 
                            y: layers[6].y, 
                            title: 'Final File State', 
                            content: 'The file now contains the original content followed by "Hello" and then "World". This order is guaranteed by the kernel\'s locking mechanisms, even though the processes attempted to write simultaneously.' 
                        }
                    ],
                    callouts: [
                        { x: 0.7, y: 0.65, content: 'Write operations completed successfully with data in the correct order' }
                    ],
                    detailView: {
                        title: 'Operation Summary',
                        code: '/* Initial file content */\n"Existing File Content"\n\n/* After Process 1 */\n"Existing File Content" + "Hello"\n\n/* After Process 2 */\n"Existing File Content" + "Hello" + "World"\n\n/* Both appends completed in the correct order */\n',
                        description: 'The kernel\'s locking and buffering mechanisms ensure that even concurrent append operations happen in a deterministic order, maintaining data integrity and consistency.'
                    }
                },
                {
                    id: 'summary',
                    title: 'Summary of the Process',
                    description: 'This visualization showed how the kernel handles concurrent file appends by using locks to ensure that only one process can modify the file size at a time. This guarantees that even with parallel processes, the data is appended in a deterministic order without corruption.',
                    state: {
                        processes: [
                            { id: 'p1', x: 0.2, y: layers[0].y, active: true, data: 'Hello', status: 'Completed' },
                            { id: 'p2', x: 0.2, y: layers[1].y, active: true, data: 'World', status: 'Completed' }
                        ],
                        arrows: [
                            { from: { x: 0.18, y: layers[0].y }, to: { x: 0.3, y: layers[3].y }, color: COLORS.process1, dashed: true },
                            { from: { x: 0.3, y: layers[3].y }, to: { x: 0.5, y: layers[5].y }, color: COLORS.process1, dashed: true },
                            { from: { x: 0.5, y: layers[5].y }, to: { x: 0.7, y: layers[6].y }, color: COLORS.process1, dashed: true },
                            { from: { x: 0.18, y: layers[1].y }, to: { x: 0.35, y: layers[3].y }, color: COLORS.process2, dashed: true },
                            { from: { x: 0.35, y: layers[3].y }, to: { x: 0.55, y: layers[5].y }, color: COLORS.process2, dashed: true },
                            { from: { x: 0.55, y: layers[5].y }, to: { x: 0.7, y: layers[6].y }, color: COLORS.process2, dashed: true }
                        ],
                        activities: [],
                        file: { x: 0.8, y: layers[6].y, content: 'File Content + Hello + World' },
                        locks: [],
                        dataPackets: []
                    },
                    hotspots: [
                        { 
                            x: 0.5, 
                            y: 0.4, 
                            title: 'Key Insights', 
                            content: '1. The kernel uses locks to prevent race conditions<br>2. Writes go through buffer cache before disk<br>3. Processes can continue execution before disk I/O completes<br>4. Ordering is preserved even with concurrent operations' 
                        }
                    ],
                    callouts: [
                        { x: 0.5, y: 0.2, content: 'Kernel mechanisms ensure data integrity during concurrent operations' }
                    ],
                    detailView: {
                        title: 'Final Takeaways',
                        code: '/* Key points */\n\n1. O_APPEND flag ensures atomic appends\n2. write() returns when data is in kernel, not on disk\n3. Inode locks prevent concurrent EOF updates\n4. Buffer cache improves performance\n5. Actual disk I/O happens asynchronously\n\n/* Result: Safe concurrent access */\n',
                        description: 'Understanding how the kernel handles concurrent file operations reveals the careful balance between performance, concurrency, and data integrity that modern operating systems maintain.'
                    }
                }
            ];
            
            // Create timeline markers
            function createTimelineMarkers() {
                timelineMarkers.innerHTML = '';
                
                steps.forEach((step, index) => {
                    const marker = document.createElement('div');
                    marker.className = 'timeline-marker';
                    marker.style.left = `${(index / (steps.length - 1)) * 100}%`;
                    marker.dataset.step = index;
                    
                    marker.addEventListener('click', () => {
                        goToStep(index);
                    });
                    
                    timelineMarkers.appendChild(marker);
                });
                
                updateTimelineMarkers();
            }
            
            function updateTimelineMarkers() {
                const markers = timelineMarkers.querySelectorAll('.timeline-marker');
                markers.forEach((marker, index) => {
                    if (index === currentStep) {
                        marker.classList.add('active');
                    } else {
                        marker.classList.remove('active');
                    }
                });
                
                // Update progress bar
                const progress = (currentStep / (steps.length - 1)) * 100;
                timelineProgress.style.width = `${progress}%`;
            }
            
            // Create hotspots
            function createHotspots() {
                // Clear existing hotspots
                hotspotsContainer.innerHTML = '';
                hotspots = [];
                
                // Add new hotspots if they exist for this step
                if (steps[currentStep].hotspots) {
                    steps[currentStep].hotspots.forEach((spot, index) => {
                        const hotspot = document.createElement('div');
                        hotspot.className = 'hotspot';
                        hotspot.id = `hotspot-${index}`;
                        hotspot.style.left = `${spot.x * 100}%`;
                        hotspot.style.top = `${spot.y * 100}%`;
                        
                        hotspot.addEventListener('mouseenter', () => {
                            showTooltip(hotspot, spot.title, spot.content);
                        });
                        
                        hotspot.addEventListener('mouseleave', () => {
                            hideTooltip();
                        });
                        
                        hotspotsContainer.appendChild(hotspot);
                        hotspots.push(hotspot);
                        
                        // Fade in the hotspot after a delay
                        setTimeout(() => {
                            hotspot.classList.add('active');
                        }, 500 + index * 100);
                    });
                }
            }
            
            // Create callouts
            function createCallouts() {
                // Clear existing callouts
                calloutsContainer.innerHTML = '';
                callouts = [];
                
                // Add new callouts if they exist for this step
                if (steps[currentStep].callouts) {
                    steps[currentStep].callouts.forEach((calloutData, index) => {
                        const callout = document.createElement('div');
                        callout.className = 'callout';
                        callout.innerHTML = calloutData.content;
                        callout.style.left = `${calloutData.x * 100}%`;
                        callout.style.top = `${calloutData.y * 100}%`;
                        callout.style.transform = 'translate(-50%, -50%)';
                        
                        calloutsContainer.appendChild(callout);
                        callouts.push(callout);
                        
                        // Fade in the callout after a delay
                        setTimeout(() => {
                            callout.classList.add('active');
                        }, 800 + index * 150);
                    });
                }
            }
            
            // Update detail view
            function updateDetailView() {
                const detailData = steps[currentStep].detailView;
                
                if (detailData) {
                    const detailTitle = document.createElement('h4');
                    detailTitle.textContent = detailData.title;
                    
                    const codeBlock = document.createElement('div');
                    codeBlock.className = 'code-block';
                    codeBlock.textContent = detailData.code;
                    
                    const description = document.createElement('p');
                    description.textContent = detailData.description;
                    
                    detailView.innerHTML = '';
                    detailView.appendChild(detailTitle);
                    detailView.appendChild(codeBlock);
                    detailView.appendChild(description);
                    
                    // Add jump buttons
                    const jumpControls = document.createElement('div');
                    jumpControls.className = 'jump-controls';
                    
                    const prevButton = document.createElement('button');
                    prevButton.className = 'jump-btn';
                    prevButton.id = 'prevJumpBtn';
                    prevButton.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none"><polyline points="15 18 9 12 15 6"></polyline></svg> Previous';
                    prevButton.addEventListener('click', () => {
                        if (currentStep > 0) goToStep(currentStep - 1);
                    });
                    prevButton.disabled = currentStep === 0;
                    
                    const nextButton = document.createElement('button');
                    nextButton.className = 'jump-btn';
                    nextButton.id = 'nextJumpBtn';
                    nextButton.innerHTML = 'Next <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none"><polyline points="9 18 15 12 9 6"></polyline></svg>';
                    nextButton.addEventListener('click', () => {
                        if (currentStep < steps.length - 1) goToStep(currentStep + 1);
                    });
                    nextButton.disabled = currentStep === steps.length - 1;
                    
                    jumpControls.appendChild(prevButton);
                    jumpControls.appendChild(nextButton);
                    
                    detailView.appendChild(jumpControls);
                    
                    detailView.classList.add('active');
                } else {
                    detailView.classList.remove('active');
                }
            }
            
            // Show tooltip
            function showTooltip(element, title, content) {
                const rect = element.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                
                tooltip.innerHTML = `<h4>${title}</h4><p>${content}</p>`;
                
                // Position tooltip relative to hotspot
                const tooltipX = rect.left - canvasRect.left + rect.width / 2;
                let tooltipY = rect.top - canvasRect.top - 10;
                
                // Check if tooltip would go off the top
                if (tooltipY - tooltip.offsetHeight < 0) {
                    tooltipY = rect.bottom - canvasRect.top + 10;
                    tooltip.style.transform = 'translate(-50%, 0)';
                } else {
                    tooltip.style.transform = 'translate(-50%, -100%)';
                }
                
                tooltip.style.left = `${tooltipX}px`;
                tooltip.style.top = `${tooltipY}px`;
                tooltip.classList.add('active');
            }
            
            // Hide tooltip
            function hideTooltip() {
                tooltip.classList.remove('active');
            }
            
            // Create particle effect
            function createParticle(fromX, fromY, toX, toY, color) {
                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.width = '6px';
                particle.style.height = '6px';
                particle.style.borderRadius = '50%';
                particle.style.backgroundColor = color;
                particle.style.left = `${fromX * 100}%`;
                particle.style.top = `${fromY * 100}%`;
                particle.style.opacity = '0.8';
                particle.style.pointerEvents = 'none';
                
                particleContainer.appendChild(particle);
                
                // Animate the particle
                const startTime = performance.now();
                const duration = 1000 + Math.random() * 500;
                
                function animateParticle(timestamp) {
                    const elapsed = timestamp - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Use bezier curve for more natural motion
                    const x = fromX + (toX - fromX) * progress;
                    const y = fromY + (toY - fromY) * progress - Math.sin(progress * Math.PI) * 0.05;
                    
                    particle.style.left = `${x * 100}%`;
                    particle.style.top = `${y * 100}%`;
                    particle.style.opacity = 0.8 * (1 - progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateParticle);
                    } else {
                        particleContainer.removeChild(particle);
                    }
                }
                
                requestAnimationFrame(animateParticle);
            }
            
            // Generate particles for data flow
            function generateParticles() {
                const currentState = steps[currentStep].state;
                
                // Generate particles for arrows
                if (currentState.arrows) {
                    currentState.arrows.forEach(arrow => {
                        if (Math.random() < 0.3) {  // Only create particles sometimes for performance
                            createParticle(
                                arrow.from.x,
                                arrow.from.y,
                                arrow.to.x,
                                arrow.to.y,
                                arrow.color
                            );
                        }
                    });
                }
                
                // Generate particles around active processes
                if (currentState.processes) {
                    currentState.processes.forEach(process => {
                        if (process.active && Math.random() < 0.1) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 0.02 + Math.random() * 0.03;
                            createParticle(
                                process.x,
                                process.y,
                                process.x + Math.cos(angle) * distance,
                                process.y + Math.sin(angle) * distance,
                                process.id === 'p1' ? COLORS.process1 : COLORS.process2
                            );
                        }
                    });
                }
                
                // Generate particles for highlighted activities
                if (currentState.activities) {
                    currentState.activities.forEach(activity => {
                        if (activity.highlight && Math.random() < 0.2) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 0.02 + Math.random() * 0.02;
                            createParticle(
                                activity.x,
                                activity.y,
                                activity.x + Math.cos(angle) * distance,
                                activity.y + Math.sin(angle) * distance,
                                activity.color
                            );
                        }
                    });
                }
                
                // Generate particles for highlighted file
                if (currentState.file && currentState.file.highlight && Math.random() < 0.2) {
                    const file = currentState.file;
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 0.02 + Math.random() * 0.02;
                    createParticle(
                        file.x,
                        file.y,
                        file.x + Math.cos(angle) * distance,
                        file.y + Math.sin(angle) * distance,
                        COLORS.hardware
                    );
                }
            }
            
            // Resize handler
            function handleResize() {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                
                canvasWidth = rect.width;
                canvasHeight = rect.height;
                
                canvas.width = canvasWidth * dpr;
                canvas.height = canvasHeight * dpr;
                
                ctx.scale(dpr, dpr);
                
                render();
            }
            
            // Animation logic
            function startTransition() {
                isTransitioning = true;
                transitionProgress = 0;
                
                function animate() {
                    transitionProgress += 0.05;
                    
                    if (transitionProgress >= 1) {
                        transitionProgress = 1;
                        isTransitioning = false;
                        
                        if (isPlaying) {
                            // Set up automatic advance to next step
                            autoAdvanceTimer = setTimeout(() => {
                                if (currentStep < steps.length - 1) {
                                    goToStep(currentStep + 1);
                                } else {
                                    isPlaying = false;
                                    updatePlayButton();
                                }
                            }, AUTO_ADVANCE_DELAY);
                        }
                    } else {
                        animationFrameId = requestAnimationFrame(animate);
                    }
                    
                    render();
                }
                
                animationFrameId = requestAnimationFrame(animate);
            }
            
            // Update play button state
            function updatePlayButton() {
                playPauseBtn.innerText = isPlaying ? 'Pause' : 'Play';
                playIcon.style.display = isPlaying ? 'none' : 'inline';
                pauseIcon.style.display = isPlaying ? 'inline' : 'none';
            }
            
            // Go to a specific step
            function goToStep(stepIndex) {
                // Clear any existing timers
                if (autoAdvanceTimer) {
                    clearTimeout(autoAdvanceTimer);
                    autoAdvanceTimer = null;
                }
                
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                currentStep = stepIndex;
                
                // Update UI
                stepCounter.textContent = `Step ${currentStep + 1}/${steps.length}`;
                stepTitle.textContent = steps[currentStep].title;
                stepDescription.innerHTML = steps[currentStep].description;
                updateTimelineMarkers();
                
                // Update button states
                prevBtn.disabled = currentStep === 0;
                nextBtn.disabled = currentStep === steps.length - 1;
                
                // Create interactive elements
                createHotspots();
                createCallouts();
                updateDetailView();
                
                // Start transition animation
                startTransition();
            }
            
            // Draw a process circle
            function drawProcess(x, y, radius, color, lightColor, status, isActive) {
                const centerX = x * canvasWidth;
                const centerY = y * canvasHeight;
                
                // Draw glow for active processes
                if (isActive) {
                    ctx.beginPath();
                    const gradient = ctx.createRadialGradient(centerX, centerY, radius, centerX, centerY, radius * 2);
                    gradient.addColorStop(0, hexToRgba(color, 0.3));
                    gradient.addColorStop(1, hexToRgba(color, 0));
                    ctx.fillStyle = gradient;
                    ctx.arc(centerX, centerY, radius * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw main circle
                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw status text
                if (status) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(status, centerX, centerY + 4);
                }
                
                // Reset alignment
                ctx.textAlign = 'left';
            }
            
            // Draw an arrow
            function drawArrow(fromX, fromY, toX, toY, color, dashed = false) {
                const headLength = 10;
                const headWidth = 6;
                
                const startX = fromX * canvasWidth;
                const startY = fromY * canvasHeight;
                const endX = toX * canvasWidth;
                const endY = toY * canvasHeight;
                
                // Calculate angle and components
                const angle = Math.atan2(endY - startY, endX - startX);
                const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                
                // Draw the line
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                if (dashed) {
                    ctx.setLineDash([5, 5]);
                } else {
                    ctx.setLineDash([]);
                }
                
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX - headLength * Math.cos(angle), endY - headLength * Math.sin(angle));
                ctx.stroke();
                
                // Reset dash
                ctx.setLineDash([]);
                
                // Draw the arrow head
                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - headLength * Math.cos(angle) + headWidth * Math.sin(angle),
                    endY - headLength * Math.sin(angle) - headWidth * Math.cos(angle)
                );
                ctx.lineTo(
                    endX - headLength * Math.cos(angle) - headWidth * Math.sin(angle),
                    endY - headLength * Math.sin(angle) + headWidth * Math.cos(angle)
                );
                ctx.closePath();
                ctx.fill();
            }
            
            // Draw an activity box
            function drawActivity(x, y, color, content, highlight = false) {
                const centerX = x * canvasWidth;
                const centerY = y * canvasHeight;
                
                // Calculate box dimensions based on text
                ctx.font = '12px Inter';
                const textWidth = ctx.measureText(content).width;
                const boxWidth = textWidth + 40;
                const boxHeight = 36;
                
                // Draw box with rounded corners
                const radius = 8;
                
                if (highlight) {
                    // Draw glow for highlighted activities
                    ctx.beginPath();
                    const gradient = ctx.createRadialGradient(centerX, centerY, boxWidth/4, centerX, centerY, boxWidth/2);
                    gradient.addColorStop(0, hexToRgba(color, 0.2));
                    gradient.addColorStop(1, hexToRgba(color, 0));
                    ctx.fillStyle = gradient;
                    ctx.fillRect(centerX - boxWidth/2 - 10, centerY - boxHeight/2 - 10, boxWidth + 20, boxHeight + 20);
                }
                
                ctx.beginPath();
                ctx.moveTo(centerX - boxWidth/2 + radius, centerY - boxHeight/2);
                ctx.lineTo(centerX + boxWidth/2 - radius, centerY - boxHeight/2);
                ctx.quadraticCurveTo(centerX + boxWidth/2, centerY - boxHeight/2, centerX + boxWidth/2, centerY - boxHeight/2 + radius);
                ctx.lineTo(centerX + boxWidth/2, centerY + boxHeight/2 - radius);
                ctx.quadraticCurveTo(centerX + boxWidth/2, centerY + boxHeight/2, centerX + boxWidth/2 - radius, centerY + boxHeight/2);
                ctx.lineTo(centerX - boxWidth/2 + radius, centerY + boxHeight/2);
                ctx.quadraticCurveTo(centerX - boxWidth/2, centerY + boxHeight/2, centerX - boxWidth/2, centerY + boxHeight/2 - radius);
                ctx.lineTo(centerX - boxWidth/2, centerY - boxHeight/2 + radius);
                ctx.quadraticCurveTo(centerX - boxWidth/2, centerY - boxHeight/2, centerX - boxWidth/2 + radius, centerY - boxHeight/2);
                ctx.closePath();
                
                // Set colors and fill
                ctx.fillStyle = hexToRgba(color, 0.15);
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                
                ctx.fill();
                ctx.stroke();
                
                // Draw text
                ctx.fillStyle = COLORS.darkText;
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(content, centerX, centerY + 4);
                
                // Reset alignment
                ctx.textAlign = 'left';
            }
            
            // Draw a file
            function drawFile(x, y, content, highlight = false) {
                const centerX = x * canvasWidth;
                const centerY = y * canvasHeight;
                
                const fileWidth = 120;
                const fileHeight = 60;
                const foldWidth = 20;
                const foldHeight = 15;
                
                // Draw glow effect for highlighted files
                if (highlight) {
                    ctx.beginPath();
                    const gradient = ctx.createRadialGradient(centerX, centerY, fileWidth/2, centerX, centerY, fileWidth);
                    gradient.addColorStop(0, hexToRgba(COLORS.hardware, 0.2));
                    gradient.addColorStop(1, hexToRgba(COLORS.hardware, 0));
                    ctx.fillStyle = gradient;
                    ctx.fillRect(centerX - fileWidth/2 - 10, centerY - fileHeight/2 - 10, fileWidth + 20, fileHeight + 20);
                }
                
                // Draw file body
                ctx.beginPath();
                ctx.moveTo(centerX - fileWidth/2, centerY - fileHeight/2);
                ctx.lineTo(centerX + fileWidth/2 - foldWidth, centerY - fileHeight/2);
                ctx.lineTo(centerX + fileWidth/2, centerY - fileHeight/2 + foldHeight);
                ctx.lineTo(centerX + fileWidth/2, centerY + fileHeight/2);
                ctx.lineTo(centerX - fileWidth/2, centerY + fileHeight/2);
                ctx.closePath();
                
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = COLORS.hardware;
                ctx.lineWidth = 1.5;
                ctx.fill();
                ctx.stroke();
                
                // Draw fold
                ctx.beginPath();
                ctx.moveTo(centerX + fileWidth/2 - foldWidth, centerY - fileHeight/2);
                ctx.lineTo(centerX + fileWidth/2 - foldWidth, centerY - fileHeight/2 + foldHeight);
                ctx.lineTo(centerX + fileWidth/2, centerY - fileHeight/2 + foldHeight);
                ctx.closePath();
                ctx.fillStyle = hexToRgba(COLORS.hardware, 0.1);
                ctx.fill();
                ctx.stroke();
                
                // Draw content
                ctx.fillStyle = COLORS.darkText;
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                
                // Handle long content with wrapping
                const words = content.split(' ');
                let line = '';
                let y11 = centerY - 8;
                const lineHeight = 16;
                const maxWidth = fileWidth - 20;
                
                for (let i = 0; i < words.length; i++) {
                    const testLine = line + words[i] + ' ';
                    const metrics = ctx.measureText(testLine);
                    
                    if (metrics.width > maxWidth && i > 0) {
                        ctx.fillText(line, centerX, y11);
                        line = words[i] + ' ';
                        y11 += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, centerX, y11);
                
                // Reset alignment
                ctx.textAlign = 'left';
            }
            
            // Draw a lock
            function drawLock(x, y, locked, owner, message) {
                const centerX = x * canvasWidth;
                const centerY = y * canvasHeight;
                
                const lockWidth = 20;
                const lockHeight = 25;
                const shackleRadius = 10;
                
                // Set colors based on lock state and owner
                let lockColor;
                if (locked) {
                    lockColor = owner === 'p1' ? COLORS.process1 : COLORS.process2;
                } else {
                    lockColor = '#aaaaaa';
                }
                
                // Draw lock body
                ctx.beginPath();
                ctx.rect(centerX - lockWidth/2, centerY - lockHeight/4, lockWidth, lockHeight/2);
                ctx.fillStyle = hexToRgba(lockColor, 0.2);
                ctx.strokeStyle = lockColor;
                ctx.lineWidth = 2;
                ctx.fill();
                ctx.stroke();
                
                // Draw lock shackle
                ctx.beginPath();
                ctx.lineWidth = 2;
                
                if (locked) {
                    // Closed shackle
                    ctx.arc(centerX, centerY - lockHeight/4, lockWidth/2, Math.PI, 0, false);
                } else {
                    // Open shackle
                    ctx.arc(centerX - lockWidth/4, centerY - lockHeight/4, lockWidth/2, Math.PI, 0, false);
                    ctx.lineTo(centerX, centerY - lockHeight);
                }
                
                ctx.stroke();
                
                // Draw message
                if (message) {
                    ctx.fillStyle = COLORS.darkText;
                    ctx.font = '11px Inter';
                    ctx.textAlign = 'left';
                    ctx.fillText(message, centerX + lockWidth, centerY);
                }
                
                // Reset alignment
                ctx.textAlign = 'left';
            }
            
            // Draw a data packet
            function drawDataPacket(x, y, color, data, position) {
                const centerX = x * canvasWidth;
                const centerY = y * canvasHeight;
                
                const width = 70;
                const height = 30;
                
                // Draw diamond shape for data packet
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - height/2);
                ctx.lineTo(centerX + width/2, centerY);
                ctx.lineTo(centerX, centerY + height/2);
                ctx.lineTo(centerX - width/2, centerY);
                ctx.closePath();
                
                ctx.fillStyle = hexToRgba(color, 0.2);
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                ctx.fill();
                ctx.stroke();
                
                // Draw data content
                ctx.fillStyle = COLORS.darkText;
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(data, centerX, centerY);
                
                // Draw position if provided
                if (position) {
                    ctx.font = '10px Inter';
                    ctx.fillText(position, centerX, centerY + 14);
                }
                
                // Reset alignment
                ctx.textAlign = 'left';
            }
            
            // Convert hex to rgba
            function hexToRgba(hex, alpha) {
                if (hex.startsWith('#')) {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                return hex; // If it's already rgba
            }
            
            // Draw the visualization layers
            function drawLayers() {
                // Draw separation lines
                ctx.strokeStyle = COLORS.border;
                ctx.lineWidth = 1;
                
                // User/Kernel boundary
                ctx.beginPath();
                ctx.setLineDash([5, 3]);
                ctx.moveTo(50, (layers[1].y + 0.05) * canvasHeight);
                ctx.lineTo(canvasWidth - 50, (layers[1].y + 0.05) * canvasHeight);
                ctx.stroke();
                
                // Draw label for user space
                ctx.fillStyle = COLORS.midText;
                ctx.font = 'italic 12px Inter';
                ctx.fillText("User Space", 60, (layers[1].y + 0.05) * canvasHeight - 5);
                ctx.fillText("Kernel Space", 60, (layers[1].y + 0.05) * canvasHeight + 15);
                
                // Kernel/Hardware boundary
                ctx.beginPath();
                ctx.setLineDash([5, 3]);
                ctx.moveTo(50, (layers[4].y + 0.06) * canvasHeight);
                ctx.lineTo(canvasWidth - 50, (layers[4].y + 0.06) * canvasHeight);
                ctx.stroke();
                
                // Draw label for hardware
                ctx.fillStyle = COLORS.midText;
                ctx.font = 'italic 12px Inter';
                ctx.fillText("Hardware", 60, (layers[4].y + 0.06) * canvasHeight + 15);
                
                // Reset dash pattern
                ctx.setLineDash([]);
                
                // Draw each layer
                const layerHeight = canvasHeight * 0.08;
                
                layers.forEach(layer => {
                    const y = layer.y * canvasHeight;
                    
                    // Layer background
                    ctx.fillStyle = layer.lightColor;
                    ctx.fillRect(50, y - layerHeight/2, canvasWidth - 100, layerHeight);
                    
                    // Layer border
                    ctx.strokeStyle = layer.color;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(50, y - layerHeight/2, canvasWidth - 100, layerHeight);
                    
                    // Layer name
                    ctx.fillStyle = COLORS.darkText;
                    ctx.font = '12px Inter';
                    ctx.fillText(layer.name, 60, y - layerHeight/2 + 18);
                });
            }
            
            // Render state for current step
            function renderState(state, progress) {
                // If we're transitioning, we need to interpolate between states
                let currentState = state;
                
                // Draw processes
                if (currentState.processes) {
                    currentState.processes.forEach(process => {
                        drawProcess(
                            process.x,
                            process.y,
                            25,
                            process.id === 'p1' ? COLORS.process1 : COLORS.process2,
                            process.id === 'p1' ? COLORS.process1Light : COLORS.process2Light,
                            process.status,
                            process.active
                        );
                    });
                }
                
                // Draw arrows
                if (currentState.arrows) {
                    currentState.arrows.forEach(arrow => {
                        drawArrow(
                            arrow.from.x,
                            arrow.from.y,
                            arrow.to.x,
                            arrow.to.y,
                            arrow.color,
                            arrow.dashed
                        );
                    });
                }
                
                // Draw activities
                if (currentState.activities) {
                    currentState.activities.forEach(activity => {
                        drawActivity(
                            activity.x,
                            activity.y,
                            activity.color,
                            activity.content,
                            activity.highlight
                        );
                    });
                }
                
                // Draw file
                if (currentState.file) {
                    drawFile(
                        currentState.file.x,
                        currentState.file.y,
                        currentState.file.content,
                        currentState.file.highlight
                    );
                }
                
                // Draw locks
                if (currentState.locks) {
                    currentState.locks.forEach(lock => {
                        drawLock(
                            lock.x,
                            lock.y,
                            lock.locked,
                            lock.owner,
                            lock.message
                        );
                    });
                }
                
                // Draw data packets
                if (currentState.dataPackets) {
                    currentState.dataPackets.forEach(packet => {
                        drawDataPacket(
                            packet.x,
                            packet.y,
                            packet.color,
                            packet.data,
                            packet.position
                        );
                    });
                }
            }
            
            // Main render function
            function render() {
                // Clear canvas
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                
                // Draw layers
                drawLayers();
                
                // Render current state
                renderState(steps[currentStep].state, transitionProgress);
                
                // Generate particles for animation
                if (!isTransitioning && Math.random() < 0.1) {
                    generateParticles();
                }
            }
            
            // Initialize the visualization
            function init() {
                // Set up canvas
                handleResize();
                
                // Create timeline markers
                createTimelineMarkers();
                
                // Set up event listeners
                setupEventListeners();
                
                // Start with the first step
                goToStep(0);
                
                // Hide loading indicator
                loadingIndicator.style.display = 'none';
                
                // Start animation loop
                requestAnimationFrame(function loop() {
                    render();
                    requestAnimationFrame(loop);
                });
            }
            
            // Event listeners
            function setupEventListeners() {
                // Resize handling
                window.addEventListener('resize', handleResize);
                
                // Control buttons
                playPauseBtn.addEventListener('click', function() {
                    isPlaying = !isPlaying;
                    updatePlayButton();
                    
                    if (isPlaying) {
                        // If at the end, start from beginning
                        if (currentStep === steps.length - 1) {
                            goToStep(0);
                        } else if (!isTransitioning) {
                            // If not currently transitioning, start auto advance
                            autoAdvanceTimer = setTimeout(() => {
                                if (currentStep < steps.length - 1) {
                                    goToStep(currentStep + 1);
                                } else {
                                    isPlaying = false;
                                    updatePlayButton();
                                }
                            }, AUTO_ADVANCE_DELAY);
                        }
                    } else {
                        // Stop auto advance
                        if (autoAdvanceTimer) {
                            clearTimeout(autoAdvanceTimer);
                            autoAdvanceTimer = null;
                        }
                    }
                });
                
                prevBtn.addEventListener('click', function() {
                    isPlaying = false;
                    updatePlayButton();
                    if (currentStep > 0) {
                        goToStep(currentStep - 1);
                    }
                });
                
                nextBtn.addEventListener('click', function() {
                    isPlaying = false;
                    updatePlayButton();
                    if (currentStep < steps.length - 1) {
                        goToStep(currentStep + 1);
                    }
                });
                
                resetBtn.addEventListener('click', function() {
                    isPlaying = false;
                    updatePlayButton();
                    goToStep(0);
                });
            }
            
            // Initialize
            init();
        });
    </script>
</body>
</html>
